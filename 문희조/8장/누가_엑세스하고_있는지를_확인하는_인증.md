## 🤷‍♂️ 누가 액세스하고 있는지를 확인하는 인증

### 8.1 인증이란?

-   실제로 누가 접근하려고 하는건지 알 수가 없다.
-   따라서, `등록한 본인만 아는 정보`, `등록한 본인만 가진 정보`로 확인해야 한다.
-   이런 정보는 보통 `비밀번호`, `일회성 토큰`, `전자 증명서`, `바이오 매트릭스`, `IC 카드`를 사용한다.
-   앞으로 설명할 인증 방법 외에도 Windows 인증 등도 존재한다.

### 8.2 BASIC 인증

-   HTTP/1.0에서 구현된 인증 방식이다.
-   웹 서버와 대응하는 클라이언트 사이에서 이루어지는 인증 방식이다.
-   `Base64`라는 인코딩을 사용하지만 `암호화` 자체는 아니기에 보안성이 떨어진다.

#### 8.2.1 인증 절차

1.  요청에 인증이 필요하면 서버는 `401 상태코드로` 응답한다.
2.  클라이언트는 `아이디:패스워드`를 `Base64`로 인코딩하고 `Authorization` 헤더에 담아 서버에 전송한다.
3.  서버는 인증에 성공하면 `200`과 리소스를, 실패하면 `401` 상태코드로 응답한다.

### 8.3 DIGEST 인증

-   `챌린지 리스폰스`를 사용하는 인증 방식이다.
-   `챌린지 리스폰스`: 인증 요청 > 챌린지 코드 수신 > 챌린지 코드로 계산 후 응답
-   `챌린지 코드(nonce)`는 `401`응답마다 다르다. (매번 생성된다.)
-   계산 결과를 보내기 때문에 BASIC 인증보다는 낫지만 이외의 위장에 대한 보안이 떨어진다.

#### 8.3.1 인증 절차

1.  요청에 인증이 필요하면 서버는 `401`상태코드와 `WWW-Authenticate` 헤더에 `챌린지 코드(nonce)`를 담아 응답한다.
2.  클라이언트는 `챌린지 코드`와 비밀번호를 `MD5`로 계산한 리스폰스 코드를 `Authorization` 헤더에 담아 서버에 전송한다.
3.  서버는 인증에 성공하면 `200`과 리소스를, 실패하면 `401` 상태코드로 응답한다.

### 8.4 SSL 클라이언트 인증

-   HTTPS의 클라이언트 인증서를 이용한 인증 방식이다.
-   (복습) 클라이언트 증명서를 인증할 때만 사용하는 방식으로 사전에 등록된 클라이언트에서의 액세스인지 확인한다.
-   단독으로 사용되지 않고, 폼 베이스 인증과 같이 진행한다. (2-factor 인증)
-   `7장`에서 다룬 것처럼 추가적인 비용을 동반한다. (증명서 발급 등)

#### 8.4.1 인증 절차

1.  요청에 인증이 필요하면 서버는 증명서를 요청하는 `Certificate Request` 메시지를 보낸다.
2.  클라이언트는 증명서를 보내고, 인증에 성공하면 공개키를 얻는다.

### 8.5 폼 베이스 인증

-   HTTP 정식 인증 방식은 아니다. 서버에서 사용하는 `Credential`을 통해서 인증하는 방식이다.
-   인증은 대부분 폼 베이스 인증 방식을 사용한다. (보안성 이슈, 비용 이슈)
-   `세션 관리`와 `쿠키`를 통해서 HTTP에 없는 상태 관리 기능을 보충하는 방식으로 구현한다.

#### 8.5.1 인증 절차

1.  `POST`메소드로 `Credential`를 바디에 담아서 보낸다. 통신은 HTTPS를 사용한다.
2.  인증에 성공하면 서버는 `세션 ID`를 발행하고 `Set-Cookie`헤더에 담아 응답한다.
3.  클라이언트는 받은 `세션 ID`를 쿠키에 저장한다.
